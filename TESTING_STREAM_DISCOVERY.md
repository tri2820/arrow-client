# Arrow Client Testing Guide

## Testing RTSP Stream Discovery

### Prerequisites
- Arrow Client built with discovery feature: `cargo build --features discovery`
- ClearCam app installed on another device (phone/tablet)
- Both devices on the same network

### Test Steps

1. **Start RTSP Stream on Another Device**
   - Open ClearCam app on phone/tablet
   - Start RTSP stream (default port 8554)
   - Note the IP address of the streaming device

2. **Run Arrow Client Discovery**
   ```bash
   sudo ./target/debug/arrow-client arr-rs.angelcam.com:8900 \
     -d -c root-g1.pem -c root-g2.pem --log-stderr -v
   ```

3. **Verify Discovery**
   - Check logs for RTSP service detection
   - Verify camera appears in `/etc/arrow/config.json`
   - Confirm stream path (usually `/stream` or `/live`)

### Expected Results
- Camera detected as RTSP service type 1
- Stream accessible via `rtsp://<IP>:8554/<path>`
- Service registered in Angelcam cloud after pairing

### Troubleshooting
- Ensure both devices on same subnet
- Check firewall settings
- Verify RTSP port (8554) is accessible
- Add custom paths to `/etc/arrow/rtsp-paths` if needed

---

## Arrow Protocol Architecture

### Overview
The Arrow Client acts as a **transparent TCP proxy** that creates secure tunnels from local cameras to the Angelcam cloud. It does NOT parse RTSP protocol or extract video streams - instead, it forwards raw TCP packets bidirectionally.

### Stream Forwarding Mechanism

**Architecture:**
```
Camera (RTSP) ←→ Arrow Client (TCP Proxy) ←→ TLS Connection ←→ Angelcam Cloud ←→ Viewers
```

**Key Design Points:**
- **Protocol-agnostic**: Client doesn't understand RTSP - just forwards TCP packets
- **Single TLS connection**: All camera streams multiplexed over one secure connection to cloud
- **Session-based**: Each viewer/camera connection gets a unique session ID
- **Transparent tunneling**: RTSP commands and RTP video data passed through unchanged

### Why Sessions? Understanding the Design

#### What are Sessions?

**Service ID (Camera ID):**
- Identifies which camera/service to connect to
- Persistent identifier from service discovery
- Example: Camera #5 at `192.168.1.100:554`

**Session ID:**
- Identifies a specific connection instance to that camera
- Ephemeral, created/destroyed per viewer
- Generated by Angelcam cloud
- Example: Viewer's session #0x1001 to Camera #5

#### Why Not Just Camera IDs?

Sessions enable **multiple concurrent viewers** of the same camera:

```
Camera #5 (Service ID: 0x0005)
├── Session #0x1001 (Viewer 1's connection)
├── Session #0x1002 (Viewer 2's connection)
└── Session #0x1003 (Viewer 3's connection)
```

Each session has:
- **Independent flow control** (64KB buffer windows)
- **Separate error handling** (one session failure doesn't affect others)
- **Per-viewer state management**
- **Clean lifecycle** (created on-demand, destroyed when viewer disconnects)

### Session Lifecycle

#### Control Messages

**CONNECT Message** - Initiates new session:
```rust
struct ConnectMessage {
    service_id: u16,    // Which camera to connect to
    session_id: u32,    // Unique session identifier (from cloud)
}
```

**DATA_ACK Message** - Flow control:
```rust
struct DataAckMessage {
    session_id: u32,    // Which session
    length: u32,        // How many more bytes can be sent
}
```

**HUP Message** - Terminates session:
```rust
struct HupMessage {
    session_id: u32,    // Which session to close
    error_code: u32,    // Why (0 = normal, others = error)
}
```

#### Typical Flow

1. **Viewer connects** → Cloud sends `CONNECT(service_id=5, session_id=0x1001)`
2. **Client creates TCP connection** to camera for this session
3. **Bidirectional forwarding** begins with flow control via `DATA_ACK`
4. **Viewer disconnects** → Cloud sends `HUP(session_id=0x1001)`
5. **Client closes TCP connection** to camera

### Why Multiple Sessions Are Needed

#### RTSP Protocol Requirements

Each RTSP connection requires **unique initialization**:

```
Viewer 1 RTSP Session:
  OPTIONS rtsp://camera/stream
  DESCRIBE rtsp://camera/stream
  SETUP ... Transport: RTP/AVP;unicast;client_port=5000-5001
  PLAY rtsp://camera/stream

Viewer 2 RTSP Session:
  OPTIONS rtsp://camera/stream
  DESCRIBE rtsp://camera/stream
  SETUP ... Transport: RTP/AVP;unicast;client_port=5002-5003
  PLAY rtsp://camera/stream
```

**Key differences:**
- Each `SETUP` negotiates **different RTP/RTCP ports**
- Independent **RTSP session state** (sequence numbers, timeouts)
- Separate **authentication** if required

#### Camera Multi-Session Support

**How cameras handle multiple connections:**

```c
// Typical camera firmware (simplified)
#define MAX_RTSP_SESSIONS 4

struct RtspSession {
    int session_id;
    tcp_socket socket;
    bool is_active;
};

// Camera duplicates video frames to all active sessions
void send_video_frame(h264_frame frame) {
    for (int i = 0; i < MAX_RTSP_SESSIONS; i++) {
        if (sessions[i].is_active) {
            send(sessions[i].socket, frame);
        }
    }
}
```

**Common limits:**
- Consumer cameras: 2-4 concurrent sessions
- Enterprise cameras: 10-20+ concurrent sessions
- One H.264 encoder output → duplicated to all sessions (efficient)

#### PTZ Control Conflicts

**Problem: Physical camera has single state**

```c
// Camera PTZ state (single shared state)
struct PtzState {
    float pan, tilt, zoom;
    pthread_mutex_t lock;
};

// Last command wins - no coordination!
void handle_ptz_command(int session_id, PtzCommand cmd) {
    pthread_mutex_lock(&global_ptz_state.lock);
    execute_ptz_command(cmd);  // Moves physical camera
    pthread_mutex_unlock(&global_ptz_state.lock);
}
```

**Camera firmware approaches:**

1. **No Protection (Most Common):**
   - Any session can send PTZ commands
   - Commands conflict and cause erratic camera movement
   - Last command wins

2. **First-Come-First-Served (Cheap Cameras):**
   - First session to send PTZ command locks control
   - Other sessions receive "PTZ locked" error
   - Control released when session closes

3. **Priority-Based (Enterprise Cameras):**
   - Admin users can override regular users
   - Configurable priority levels via ONVIF
   - Higher priority sessions take control

**Real-world examples:**
- **Hikvision DS-2CD2143G0**: 20 connections, no PTZ locking (chaos)
- **Axis P5635-E**: 20+ connections, priority-based PTZ control

### Cloud-Side Optimizations

#### Fan-Out Architecture (Optimal for Viewing)

Instead of multiple sessions per camera, cloud can do intelligent fan-out:

```
Camera ←─ Single RTSP Session ─→ Client ─→ Cloud ─→ Fan Out ─→ Viewer 1
                                                          ├─→ Viewer 2 (paused)
                                                          └─→ Viewer 3
```

**How it works:**
1. **First viewer** (0→1) → Cloud creates one session to camera
2. **Additional viewers** → Cloud duplicates stream, no new camera sessions
3. **Viewer pauses** → Cloud stops sending packets to that viewer (pseudo-pause)
4. **Last viewer** disconnects → Cloud destroys session

**Benefits:**
- ✅ Saves camera bandwidth/resources
- ✅ Reduces camera connection limits impact
- ✅ Cloud handles all viewer management
- ✅ Works for 90% of use cases (passive viewing)

#### When Fan-Out Breaks Down

**Scenarios requiring multiple sessions:**

1. **PTZ Control:**
   - Multiple viewers want to control camera simultaneously
   - Need separate sessions OR cloud-side arbitration

2. **Different Stream Profiles:**
   - Viewer 1: 1080p H.264 main stream
   - Viewer 2: 480p sub-stream for mobile
   - Camera outputs different profiles on different RTSP URLs

3. **Two-Way Audio (Backchannel):**
   - Multiple viewers want to talk through camera
   - Cannot mix audio from multiple sources simultaneously

4. **Independent Playback Control:**
   - Some cameras support trick play (rewind, fast-forward)
   - Each viewer needs independent playback state

### Session Management Implementation

#### Client-Side (Arrow Client)

```rust
// Session manager tracks all active sessions
pub struct SessionManager {
    sessions: HashMap<u32, Session>,  // session_id -> Session
    window_size: usize,                // 64KB default
}

// Each session has independent TCP connection to camera
struct Session {
    service_id: u16,     // Which camera
    session_id: u32,     // Unique identifier
    input_buffer: BytesMut,   // Data from camera → cloud
    output_buffer: BytesMut,  // Data from cloud → camera
    input_capacity: usize,    // Flow control window
    output_capacity: usize,   // Flow control window
}
```

**Flow control prevents buffer overflow:**
```rust
// Client tells cloud: "I processed 8KB, you can send 8KB more"
DATA_ACK { session_id: 0x1001, length: 8192 }

// Cloud tells client: "I forwarded 4KB to viewer, send me 4KB more"
DATA_ACK { session_id: 0x1001, length: 4096 }
```

#### Cloud-Side (Angelcam Service)

The cloud can choose between:

**Strategy A: One Session Per Viewer**
- Simple, no RTSP parsing needed
- Higher camera resource usage
- Full per-viewer control (PTZ, profiles, etc.)

**Strategy B: Single Session + Fan-Out**
- Requires RTSP protocol awareness
- Optimal for passive viewing
- Handles viewer pause/resume/buffering
- PTZ requires arbitration layer

### Design Trade-offs

#### Current Design (Multi-Session Support)

**Pros:**
- ✅ Client is simple TCP proxy (no protocol parsing)
- ✅ Supports complex scenarios (PTZ, multiple profiles)
- ✅ Full per-viewer control capabilities
- ✅ Flexible - cloud can choose strategy

**Cons:**
- ❌ Multiple sessions to camera (resource usage)
- ❌ Hits camera connection limits faster
- ❌ More bandwidth from camera to client

#### Alternative (Pure Fan-Out)

**Pros:**
- ✅ Optimal bandwidth usage
- ✅ Single session to camera
- ✅ Works great for passive viewing

**Cons:**
- ❌ Requires cloud RTSP parsing
- ❌ Complex PTZ arbitration needed
- ❌ Limited support for advanced features

**The Arrow Protocol's session design provides flexibility for both approaches!**

### Key Insights

1. **Sessions ≠ Cameras**: Sessions are connection instances, not camera identifiers
2. **RTSP Requires Sessions**: Protocol mandates per-connection state management
3. **Camera Firmware Varies**: No standard multi-user coordination (especially PTZ)
4. **Cloud Intelligence**: Smart proxies add value beyond dumb camera firmware
5. **Design Flexibility**: Protocol supports both multi-session and fan-out strategies